#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# Copyright (C) 2019  Hauke Petersen <dev@haukepetersen.de>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import io
import os
import re
import sys
import yaml
import hashlib
import argparse
import subprocess

cfg = {}
env = {}

def env_load(envfile):
    global env

    print("Reading context information from temporary file")

    with open(envfile, 'r', encoding='utf-8') as f:
        env = yaml.load(f)


def env_update(envfile):
    global env
    global cfg

    env = cfg

    print("Extracting context information")

    acmdev = subprocess.check_output(['ls /dev/ttyACM*'], shell=True).decode('utf-8')
    for dev in acmdev.splitlines():
        devinfo = subprocess.check_output(
                            ['udevadm',
                             'info',
                             '--name={}'.format(dev)]).decode('utf-8')
        m = re.search("SEGGER_J-Link_([0-9]+)", devinfo)
        if m:
            for target in env['targets']:
                if int(target['serial']) == int(m.group(1)):
                    target['port'] = dev
                    break
        else:
            print("no SEGGER fround - skipping")

    # TODO: add some verification that every target has all needed infos attached

    # finally save temp configuration
    with open(envfile, 'w', encoding='utf-8') as f:
        yaml.dump(env, f, default_flow_style=False)


def main(args):
    global cfg
    global env

    # check config file
    if not 'RJL_ENV' in os.environ:
        sys.exit("Error: RJL_ENV variable is not set")

    envfile = None
    with open(os.environ['RJL_ENV'], 'r', encoding='utf-8') as f:
        cfg = yaml.load(f)

        f.seek(0)
        sha1 = hashlib.sha1()
        while True:
            data = f.read()
            if not data:
                break
            sha1.update(data.encode('utf-8'))

        envfile = "/tmp/rjl-{}.yml".format(sha1.hexdigest())

    if not os.path.isfile(envfile):
        env_update(envfile)

    else:
        env_load(envfile)

    print("going for node", args.node)

    target = None
    for t in env['targets']:
        if t['name'] == args.node:
            target = t
            break

    envars = "JLINK_SERIAL={} BOARD={} PORT={}".format(
                target['serial'], target['board'], target['port'])

    if not target:
        sys.exit("Given target name invalid")

    if (args.cmd == "term"):
        cmd = "{} make -C {} term".format(envars, args.app)
        print(cmd)
        subprocess.call(cmd, shell=True)

    if (args.cmd == "kill"):
        cmd = "{} make -C {}/../hello-world flash".format(envars, args.app)
        print(cmd)
        subprocess.call(cmd, shell=True)

    if (args.cmd == "run"):
        cmd = "{} make -C {} all flash term".format(envars, args.app)
        print(cmd)
        subprocess.call(cmd, shell=True)

    else:
        print("command not found")



if __name__ == "__main__":
    p = argparse.ArgumentParser()
    p.add_argument("cmd", help="command to run")
    p.add_argument("node", help="node name")
    p.add_argument("app", help="RIOT application")
    args = p.parse_args()

    main(args)
